<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>触摸手势测试</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: #f0f0f0;
        }
        
        .test-container {
            max-width: 500px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .gesture-area {
            width: 300px;
            height: 300px;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            margin: 20px auto;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 18px;
            font-weight: bold;
            user-select: none;
            transform-origin: center;
            transition: transform 0.1s ease;
        }
        
        .status {
            background: #333;
            color: white;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }
        
        .controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin: 20px 0;
        }
        
        .btn {
            padding: 10px 20px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        
        .btn:hover {
            background: #0056b3;
        }
    </style>
</head>
<body>
    <div class="test-container">
        <h1>触摸手势测试</h1>
        <p>在下面的区域测试触摸手势：</p>
        <ul>
            <li>单指滑动：左右滑动切换</li>
            <li>双指缩放：放大缩小</li>
            <li>单指拖拽：在缩放状态下拖拽</li>
            <li>双击：放大/重置</li>
        </ul>
        
        <div class="gesture-area" id="gestureArea">
            触摸测试区域
        </div>
        
        <div class="controls">
            <button class="btn" onclick="resetGesture()">重置</button>
            <button class="btn" onclick="zoomIn()">放大</button>
            <button class="btn" onclick="zoomOut()">缩小</button>
        </div>
        
        <div class="status" id="status">
            准备就绪...
        </div>
    </div>

    <script type="module">
        // 简化版的触摸手势管理器，用于测试
        class SimpleTouchGestureManager {
            constructor(element, options = {}) {
                this.element = element
                this.options = {
                    minScale: 0.5,
                    maxScale: 3,
                    swipeThreshold: 50,
                    ...options
                }
                
                this.scale = 1
                this.translateX = 0
                this.translateY = 0
                this.isActive = false
                
                this.touches = []
                this.initialDistance = 0
                this.initialScale = 1
                this.isDragging = false
                this.dragStartX = 0
                this.dragStartY = 0
                this.startX = 0
                this.startY = 0
                this.lastTouchTime = 0
                
                this.callbacks = {}
                
                this.bindEvents()
            }
            
            bindEvents() {
                this.element.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: false })
                this.element.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false })
                this.element.addEventListener('touchend', this.handleTouchEnd.bind(this), { passive: false })
            }
            
            activate() {
                this.isActive = true
            }
            
            deactivate() {
                this.isActive = false
            }
            
            on(event, callback) {
                this.callbacks[event] = callback
            }
            
            trigger(event, data) {
                if (this.callbacks[event]) {
                    this.callbacks[event](data)
                }
            }
            
            handleTouchStart(e) {
                if (!this.isActive) return
                
                e.preventDefault()
                this.touches = Array.from(e.touches)
                
                const now = Date.now()
                
                if (this.touches.length === 1) {
                    const touch = this.touches[0]
                    this.startX = touch.clientX
                    this.startY = touch.clientY
                    
                    // 双击检测
                    if (now - this.lastTouchTime < 300) {
                        this.trigger('doubleTap', { x: touch.clientX, y: touch.clientY })
                        return
                    }
                    this.lastTouchTime = now
                    
                    if (this.scale > 1) {
                        this.isDragging = true
                        this.dragStartX = touch.clientX
                        this.dragStartY = touch.clientY
                    }
                } else if (this.touches.length === 2) {
                    this.initialDistance = this.getDistance(this.touches[0], this.touches[1])
                    this.initialScale = this.scale
                    this.isDragging = false
                }
            }
            
            handleTouchMove(e) {
                if (!this.isActive) return
                
                e.preventDefault()
                this.touches = Array.from(e.touches)
                
                if (this.touches.length === 1) {
                    const touch = this.touches[0]
                    
                    if (this.isDragging && this.scale > 1) {
                        const deltaX = touch.clientX - this.dragStartX
                        const deltaY = touch.clientY - this.dragStartY
                        
                        this.translateX += deltaX
                        this.translateY += deltaY
                        
                        this.dragStartX = touch.clientX
                        this.dragStartY = touch.clientY
                        
                        this.updateTransform()
                    }
                } else if (this.touches.length === 2) {
                    const currentDistance = this.getDistance(this.touches[0], this.touches[1])
                    const scaleChange = currentDistance / this.initialDistance
                    const newScale = Math.max(this.options.minScale, Math.min(this.options.maxScale, this.initialScale * scaleChange))
                    
                    this.scale = newScale
                    
                    if (this.scale <= 1) {
                        this.translateX = 0
                        this.translateY = 0
                    }
                    
                    this.updateTransform()
                }
            }
            
            handleTouchEnd(e) {
                if (!this.isActive) return
                
                const remainingTouches = Array.from(e.touches)
                
                if (remainingTouches.length === 0) {
                    if (this.touches.length === 1 && !this.isDragging) {
                        const deltaX = e.changedTouches[0].clientX - this.startX
                        const deltaY = e.changedTouches[0].clientY - this.startY
                        
                        if (Math.abs(deltaX) > this.options.swipeThreshold && Math.abs(deltaX) > Math.abs(deltaY)) {
                            if (deltaX > 0) {
                                this.trigger('swipeRight', { deltaX, deltaY })
                            } else {
                                this.trigger('swipeLeft', { deltaX, deltaY })
                            }
                        }
                    }
                    
                    this.isDragging = false
                    this.touches = []
                }
            }
            
            getDistance(touch1, touch2) {
                const dx = touch2.clientX - touch1.clientX
                const dy = touch2.clientY - touch1.clientY
                return Math.sqrt(dx * dx + dy * dy)
            }
            
            setScale(scale) {
                this.scale = Math.max(this.options.minScale, Math.min(this.options.maxScale, scale))
                if (this.scale <= 1) {
                    this.translateX = 0
                    this.translateY = 0
                }
                this.updateTransform()
            }
            
            setTranslate(x, y) {
                this.translateX = x
                this.translateY = y
                this.updateTransform()
            }
            
            reset() {
                this.scale = 1
                this.translateX = 0
                this.translateY = 0
                this.updateTransform()
            }
            
            updateTransform() {
                this.element.style.transform = `scale(${this.scale}) translate(${this.translateX}px, ${this.translateY}px)`
                
                // 更新状态显示
                document.getElementById('status').textContent = 
                    `缩放: ${this.scale.toFixed(2)} | 平移: (${this.translateX.toFixed(0)}, ${this.translateY.toFixed(0)})`
            }
        }
        
        // 初始化手势管理器
        const gestureArea = document.getElementById('gestureArea')
        const gestureManager = new SimpleTouchGestureManager(gestureArea)
        
        gestureManager.activate()
        
        gestureManager.on('swipeLeft', () => {
            document.getElementById('status').textContent = '检测到左滑手势'
            setTimeout(() => gestureManager.updateTransform(), 1000)
        })
        
        gestureManager.on('swipeRight', () => {
            document.getElementById('status').textContent = '检测到右滑手势'
            setTimeout(() => gestureManager.updateTransform(), 1000)
        })
        
        gestureManager.on('doubleTap', () => {
            if (gestureManager.scale === 1) {
                gestureManager.setScale(2)
            } else {
                gestureManager.reset()
            }
        })
        
        // 全局函数
        window.resetGesture = () => {
            gestureManager.reset()
        }
        
        window.zoomIn = () => {
            gestureManager.setScale(gestureManager.scale * 1.5)
        }
        
        window.zoomOut = () => {
            gestureManager.setScale(gestureManager.scale / 1.5)
        }
    </script>
</body>
</html>
